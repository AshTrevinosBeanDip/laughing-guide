-- LocalPetClient (LocalScript)
-- Place in StarterPlayer > StarterPlayerScripts
-- K = spawn pet, M = mount/dismount, T = toggle fly when mounted
-- Flying: WASD + Space (up) + LeftShift (down)
-- All visuals & UI are local-only and parented under workspace.CurrentCamera

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")
local humanoid = character:WaitForChild("Humanoid")
local camera = workspace.CurrentCamera

-- Demo owned pets (local-only)
local ownedPets = {
	{ id = "pet_1", name = "NeonPuppy", color = Color3.fromRGB(255,120,180) },
	{ id = "pet_2", name = "CloudKitten", color = Color3.fromRGB(180,200,255) },
}

-- state
local spawnedPet = nil
local mounted = false
local flying = false

-- follow config
local PET_OFFSET = Vector3.new(2, -1.2, -2) -- relative to HumanoidRootPart when following
local FOLLOW_SPEED = 12

-- flight config
local FLY_SPEED = 80

-- input state
local keysDown = {}
local moveVec = Vector3.new(0,0,0)
local ascend = 0

-- helper: create a simple procedural pet model (client-only)
local function createProceduralPet(info)
	local model = Instance.new("Model")
	model.Name = info.name or "LocalPet"

	local body = Instance.new("Part")
	body.Name = "Body"
	body.Size = Vector3.new(1.6, 1.6, 1.6)
	body.Shape = Enum.PartType.Ball
	body.Color = info.color or Color3.new(1,1,1)
	body.Material = Enum.Material.Neon
	body.CanCollide = false
	body.Anchored = false
	body.Parent = model

	local eyeL = Instance.new("Part")
	eyeL.Name = "EyeL"
	eyeL.Size = Vector3.new(0.18,0.18,0.18)
	eyeL.Shape = Enum.PartType.Ball
	eyeL.Color = Color3.new(0,0,0)
	eyeL.CanCollide = false
	eyeL.Anchored = false
	eyeL.Parent = model

	local eyeR = eyeL:Clone()
	eyeR.Name = "EyeR"
	eyeR.Parent = model

	-- Mount seat (invisible)
	local seat = Instance.new("Part")
	seat.Name = "MountSeat"
	seat.Size = Vector3.new(0.4, 0.2, 0.6)
	seat.Transparency = 1
	seat.CanCollide = false
	seat.Anchored = false
	seat.Parent = model

	-- weld constraints to keep parts together (client-side)
	for _, part in ipairs({eyeL, eyeR, seat}) do
		local weld = Instance.new("WeldConstraint")
		weld.Part0 = body
		weld.Part1 = part
		weld.Parent = body
	end

	-- set Initial positions relative to body
	body.CFrame = CFrame.new(0, 3, 0)
	eyeL.CFrame = body.CFrame * CFrame.new(0.22, 0.12, -0.6)
	eyeR.CFrame = body.CFrame * CFrame.new(-0.22, 0.12, -0.6)
	seat.CFrame = body.CFrame * CFrame.new(0, -0.6, 0)

	model.PrimaryPart = body
	return model
end

-- spawn the pet (client-only)
local function spawnPet(petInfo)
	-- remove old if exists
	if spawnedPet and spawnedPet.Parent then
		spawnedPet:Destroy()
		spawnedPet = nil
		mounted = false
		flying = false
	end

	local model
	local templates = ReplicatedStorage:FindFirstChild("PetTemplates")
	if templates and petInfo and templates:FindFirstChild(petInfo.name) then
		model = templates[petInfo.name]:Clone()
	else
		model = createProceduralPet(petInfo or { name = "LocalPet", color = Color3.new(1,1,1) })
	end

	-- parent to camera so it's local-only (not replicated to server)
	model.Parent = camera
	-- ensure PrimaryPart
	if not model.PrimaryPart then
		local p = model:FindFirstChildWhichIsA("BasePart")
		if not p then
			p = Instance.new("Part", model)
			p.Name = "Primary"
			p.Size = Vector3.new(1,1,1)
			p.Transparency = 1
		end
		model.PrimaryPart = p
	end

	-- disable collisions and physics for all parts
	for _, d in ipairs(model:GetDescendants()) do
		if d:IsA("BasePart") then
			d.CanCollide = false
			d.Massless = true
			d.CanTouch = false
		end
	end

	-- initial position near player
	model:SetPrimaryPartCFrame(hrp.CFrame * CFrame.new(PET_OFFSET))
	-- idle attributes for bobbing
	model:SetAttribute("idleY", 0)
	model:SetAttribute("idleDir", 1)

	spawnedPet = model
end

-- follow behavior when not mounted
local followConn
local function startFollow()
	if followConn then return end
	followConn = RunService.RenderStepped:Connect(function(dt)
		if not spawnedPet or not spawnedPet.PrimaryPart then return end
		if mounted then return end

		local target = hrp.CFrame * CFrame.new(PET_OFFSET)
		-- add bobbing
		local idleY = spawnedPet:GetAttribute("idleY") or 0
		local idleDir = spawnedPet:GetAttribute("idleDir") or 1
		idleY = idleY + idleDir * dt * 1.5
		if idleY > 0.5 then idleDir = -1 end
		if idleY < -0.5 then idleDir = 1 end
		spawnedPet:SetAttribute("idleY", idleY)
		spawnedPet:SetAttribute("idleDir", idleDir)

		local final = target * CFrame.new(0, idleY * 0.12, 0)
		local current = spawnedPet.PrimaryPart.CFrame
		local newCFrame = current:Lerp(final, math.clamp(FOLLOW_SPEED * dt, 0, 1))
		spawnedPet:SetPrimaryPartCFrame(newCFrame)
	end)
end

local function stopFollow()
	if followConn then
		followConn:Disconnect()
		followConn = nil
	end
end

-- mounting implementation (client-only): we lerp the HRP to the pet seat and lock controls locally
local mountLoop
local function mountPet()
	if not spawnedPet or not spawnedPet.PrimaryPart then return end
	if mounted then return end

	local seat = spawnedPet:FindFirstChild("MountSeat", true) or spawnedPet.PrimaryPart
	-- stop follow and begin mounting transition
	stopFollow()
	mounted = true
	humanoid.Sit = true
	humanoid.PlatformStand = true -- prevent default animations moving the character

	-- start mount loop to keep player on pet visually
	mountLoop = RunService.RenderStepped:Connect(function(dt)
		if not mounted then return end
		if not seat or not seat:IsDescendantOf(camera) then return end

		local targetCFrame = seat.CFrame * CFrame.new(0, 1.2, 0) -- offset so player sits above seat
		-- smooth lerp to position (we set HRP CFrame directly local-only)
		hrp.CFrame = hrp.CFrame:lerp(targetCFrame, math.clamp(12 * dt, 0, 1))
	end)
end

local function dismountPet()
	if not mounted then return end
	mounted = false
	humanoid.Sit = false
	humanoid.PlatformStand = false
	if mountLoop then
		mountLoop:Disconnect()
		mountLoop = nil
	end
	-- move player slightly forward to avoid clipping
	hrp.CFrame = hrp.CFrame * CFrame.new(0, 0, 2)
	-- resume follow
	startFollow()
	-- stop flying if needed
	if flying then
		flying = false
	end
end

-- flying (client-only): uses BodyVelocity + BodyGyro on HRP (local only)
local flyConn
local flyVel, flyGyro
local function startFly()
	if not mounted or flying then return end
	flying = true

	-- create local BodyVelocity and BodyGyro (client-owned)
	flyVel = Instance.new("BodyVelocity")
	flyVel.MaxForce = Vector3.new(1e5, 1e5, 1e5)
	flyVel.P = 1e4
	flyVel.Velocity = Vector3.new(0,0,0)
	flyVel.Parent = hrp

	flyGyro = Instance.new("BodyGyro")
	flyGyro.MaxTorque = Vector3.new(1e5, 1e5, 1e5)
	flyGyro.P = 1e4
	flyGyro.Parent = hrp

	flyConn = RunService.RenderStepped:Connect(function(dt)
		if not flying or not mounted then return end
		local cam = workspace.CurrentCamera
		local look = cam.CFrame.LookVector
		local right = cam.CFrame.RightVector
		local up = Vector3.new(0,1,0)

		local desired = Vector3.new(0,0,0)
		desired = desired + look * (-moveVec.Z)
		desired = desired + right * (moveVec.X)
		desired = desired + up * ascend

		flyVel.Velocity = desired * FLY_SPEED

		-- face where camera faces
		local target = CFrame.new(hrp.Position, hrp.Position + cam.CFrame.LookVector)
		flyGyro.CFrame = target
	end)
end

local function stopFly()
	if flyConn then
		flyConn:Disconnect()
		flyConn = nil
	end
	if flyVel then flyVel:Destroy() flyVel = nil end
	if flyGyro then flyGyro:Destroy() flyGyro = nil end
	flying = false
end

-- input handling
UserInputService.InputBegan:Connect(function(input, gp)
	if gp then return end
	if input.UserInputType == Enum.UserInputType.Keyboard then
		keysDown[input.KeyCode] = true

		if input.KeyCode == Enum.KeyCode.K then
			-- spawn default pet
			local p = ownedPets[1] or { name = "LocalPet", color = Color3.new(1,1,1) }
			spawnPet(p)
			startFollow()
		elseif input.KeyCode == Enum.KeyCode.M then
			if not spawnedPet then return end
			if mounted then
				dismountPet()
				stopFly()
			else
				mountPet()
			end
		elseif input.KeyCode == Enum.KeyCode.T then
			if mounted then
				if not flying then
					startFly()
				else
					stopFly()
				end
			end
		end
	end
end)

UserInputService.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.Keyboard then
		keysDown[input.KeyCode] = nil
	end
end)

-- update moveVec & ascend each frame
RunService.RenderStepped:Connect(function()
	local x,z = 0,0
	if keysDown[Enum.KeyCode.W] then z = z - 1 end
	if keysDown[Enum.KeyCode.S] then z = z + 1 end
	if keysDown[Enum.KeyCode.A] then x = x - 1 end
	if keysDown[Enum.KeyCode.D] then x = x + 1 end
	moveVec = Vector3.new(x,0,z)

	ascend = 0
	if keysDown[Enum.KeyCode.Space] then ascend = 1 end
	if keysDown[Enum.KeyCode.LeftShift] then ascend = -1 end
end)

-- simple local trade UI (local-only)
local function createTradeUI()
	local gui = Instance.new("ScreenGui")
	gui.Name = "LocalPetTradeUI"
	gui.ResetOnSpawn = false
	gui.Parent = player:WaitForChild("PlayerGui")

	local frame = Instance.new("Frame")
	frame.Size = UDim2.new(0, 400, 0, 240)
	frame.Position = UDim2.new(0, 18, 0, 60)
	frame.BackgroundTransparency = 0.15
	frame.BackgroundColor3 = Color3.fromRGB(20,20,24)
	frame.Parent = gui

	local title = Instance.new("TextLabel", frame)
	title.Size = UDim2.new(1, -40, 0, 28)
	title.Position = UDim2.new(0, 20, 0, 8)
	title.BackgroundTransparency = 1
	title.Text = "Local Pet Trade (local-only)"
	title.TextColor3 = Color3.new(1,1,1)
	title.Font = Enum.Font.GothamBold
	title.TextSize = 18
	title.TextXAlignment = Enum.TextXAlignment.Left

	local petsLabel = Instance.new("TextLabel", frame)
	petsLabel.Size = UDim2.new(0.5, -20, 0, 20)
	petsLabel.Position = UDim2.new(0, 20, 0, 44)
	petsLabel.BackgroundTransparency = 1
	petsLabel.Text = "Your Pets:"
	petsLabel.TextColor3 = Color3.new(1,1,1)
	petsLabel.TextXAlignment = Enum.TextXAlignment.Left

	local petsFrame = Instance.new("Frame", frame)
	petsFrame.Size = UDim2.new(0.5, -20, 0, 140)
	petsFrame.Position = UDim2.new(0, 20, 0, 72)
	petsFrame.BackgroundTransparency = 0.3

	local UIList = Instance.new("UIListLayout", petsFrame)
	UIList.SortOrder = Enum.SortOrder.LayoutOrder
	UIList.Padding = UDim.new(0,6)

	for _, p in ipairs(ownedPets) do
		local b = Instance.new("TextButton", petsFrame)
		b.Size = UDim2.new(1, -12, 0, 28)
		b.Position = UDim2.new(0, 6, 0, 0)
		b.Text = p.name
		b.Name = p.id
		b.BackgroundTransparency = 0.15
		b.TextColor3 = Color3.new(1,1,1)
		b.Activated:Connect(function()
			spawnPet(p)
			startFollow()
		end)
	end

	-- offer box & button
	local offerBox = Instance.new("TextBox", frame)
	offerBox.Size = UDim2.new(0.45, -20, 0, 90)
	offerBox.Position = UDim2.new(0.52, 0, 0, 72)
	offerBox.PlaceholderText = "Type pet id or name to offer (local only)"
	offerBox.Text = ""
	offerBox.ClearTextOnFocus = false

	local offerBtn = Instance.new("TextButton", frame)
	offerBtn.Size = UDim2.new(0.45, -20, 0, 28)
	offerBtn.Position = UDim2.new(0.52, 0, 0, 172)
	offerBtn.Text = "Propose Local Trade"
	offerBtn.Activated:Connect(function()
		local input = offerBox.Text
		local found
		for _, p in ipairs(ownedPets) do
			if p.id == input or p.name == input then found = p break end
		end
		if not found then
			offerBox.Text = ""
			offerBox.PlaceholderText = "Pet not found locally"
			return
		end
		local popup = Instance.new("TextLabel", gui)
		popup.Size = UDim2.new(0, 300, 0, 80)
		popup.Position = UDim2.new(0.5, -150, 0.5, -40)
		popup.BackgroundTransparency = 0.1
		popup.BackgroundColor3 = Color3.fromRGB(22,22,26)
		popup.TextColor3 = Color3.new(1,1,1)
		popup.TextWrapped = true
		popup.Text = "Local trade requested for: "..found.name.."\n(This is only a local simulation.)"
		delay(2, function() if popup and popup.Parent then popup:Destroy() end end)
	end)

	local inst = Instance.new("TextLabel", frame)
	inst.Size = UDim2.new(1, -40, 0, 20)
	inst.Position = UDim2.new(0, 20, 1, -30)
	inst.BackgroundTransparency = 1
	inst.TextColor3 = Color3.fromRGB(200,200,200)
	inst.Text = "K = spawn, M = mount/dismount, T = toggle fly. Local visuals only."
	inst.TextWrapped = true
	inst.Font = Enum.Font.SourceSans
	inst.TextSize = 12
end

-- create UI
createTradeUI()

-- Respawn handling
player.CharacterAdded:Connect(function(char)
	character = char
	hrp = character:WaitForChild("HumanoidRootPart")
	humanoid = character:WaitForChild("Humanoid")
	-- if pet existed, respawn it near new character
	if spawnedPet and spawnedPet.Parent then
		-- move pet to new character
		spawnedPet:SetPrimaryPartCFrame(hrp.CFrame * CFrame.new(PET_OFFSET))
	end
end)

-- optional: spawn first pet on load
-- spawnPet(ownedPets[1]); startFollow()
